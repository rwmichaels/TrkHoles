{
  // Find residuals between tracks and holes for PREX data
  // R. Michaels   June, 2021.
  //
  // control which spectometer with the first line "Which_Spectrometer"
  //
  // holes.dat is a link to the file with the sieve slit hole info.  e.g.
  // holes.dat -> ./holefiles/holes2240.dat
  //
  // AfileL.root or AfileR.root is a link
  // to the ROOT file generated by the Podd analyzer
  // Example:
  // AfileL.root -> ./rootfiles/prexLHRS_2240_siyu.root
  //
  // I got my root files from Siyu and checked them with lower statistics.
  //
  // To run the macro
  // root .x TrkHoles.C
  //
  // Some global checking histograms are available.
  // root [3] hrad->Draw()   
  // root [4] hthdiff->Draw()
  // root [5] hphdiff->Draw()
  // root [6] hf1->Draw("box")
  // root [7] hf0->Draw("box")
  //
  // Look at all the residual histograms by hand, for example
  // root [18] thres11_4->Draw()
  // root [19] phres11_4->Draw()
  // root [20] thres10_1->Draw()
  // root [21] phres10_1->Draw()
  // root [26] thres10_4->Draw()
  // root [27] phres10_4->Draw()
  // root [28] thres9_1->Draw()
  // root [29] phres9_1->Draw()
  // root [30] thres9_2->Draw()
  // root [31] phres9_2->Draw()
  
#include <string.h>
#include <stdio.h>
#include <vector>
  
  string Which_Spectrometer="R";   // change from L to R  (left vs right HRS)

  char RootFile[80];
  char ThetaVarName[80];
  char PhiVarName[80];
  Int_t MAXEVENTS = 500000; // max num events
  Int_t numevts;  // = min of (MAXEVENTS, num entrees in Tree)
  Int_t verbose=0;
  Double_t THWID=0.004;  // this is an empirical resolution
  Double_t PHWID=0.002;
  Int_t icol,jrow,idx,icolmin,irowmin,kk,kfind,skipit;
  Int_t row,col;
  Float_t ftgth,ftgph;
  Long64_t tent=0;
  Int_t NCOL=15;  // max number; actually 10 (sometimes 9)
  Int_t NROW=10;  // rows
  Int_t *col_has_hole,*hole_found;
  Double_t *tgth_hole, *tgph_hole;
  Double_t thdiff,phdiff;
  Double_t thdiff_save,phdiff_save;
  Double_t rrad, rrmin, rrtol;
  vector<TH1F*> hres_th;
  vector<TH1F*> hres_ph;
  vector<Int_t> htoi;
  Double_t dtgth,dtgph;
  Double_t *dum;
  char cname[80];
  char ctitle[80];
   Int_t nbin=100;
  Double_t thlo=-0.008;
  Double_t thhi= 0.008;
  Double_t phlo=-0.004;
  Double_t phhi= 0.004;
  col_has_hole = new Int_t[NCOL];
  hole_found = new Int_t[NCOL*NROW];
  tgth_hole = new Double_t[NCOL*NROW];  
  tgph_hole = new Double_t[NCOL*NROW];
  dum = new Double_t[10000];
  
  FILE *fd;
  fd = fopen("holes.dat", "r");  // holes.dat is a link; see above
  if (fd == NULL) {
    cout << "missing input HOLE file !!   Cannot continue. "<<endl;
    exit;
  }

  TH2F *hf0 = new TH2F("hf0","NOT found holes ",100,-0.03,0.03,100,-0.05,0.05);
  TH2F *hf1 = new TH2F("hf1","Found holes ",100,-0.03,0.03,100,-0.05,0.05);

  // ROOT file with Podd variables.
  sprintf(RootFile,"Afile%s.root",Which_Spectrometer.c_str());

  TFile *file0 = TFile::Open(RootFile);

  TTree *T = (TTree *)file0->Get("T");

  if (T) {
     cout << "Found tree "<<endl;
  } else {
     cout << "No tree found ! "<<endl;
     exit(0);
  }

  sprintf(ThetaVarName,"%s.tr.tg_th",Which_Spectrometer.c_str());
  sprintf(PhiVarName,"%s.tr.tg_ph",Which_Spectrometer.c_str());

  cout << "Var names to look for  "<<ThetaVarName<<"   "<<PhiVarName<<endl;
  
  T->SetBranchAddress(ThetaVarName,&dtgth);
  T->SetBranchAddress(PhiVarName,&dtgph);
   
  TH1F *hthdiff = new TH1F("hthdiff","Diffs in tg_th ",200,-0.02,0.02);
  TH1F *hphdiff = new TH1F("hphdiff","Diffs in tg_ph ",100,-0.01,0.01);
  TH1F *hrad = new TH1F("hrad","Radius in angle space (units of sigma)",100,-0.1,5.0);
  
  for (icol=0; icol<NCOL; icol++) {
    col_has_hole[icol]=0;  // 0 not found, +1 found
    for (jrow=0; jrow<NROW; jrow++) {
      idx = icol*NROW + jrow;
      hole_found[idx]=0;
      sprintf(cname,"thres%d_%d",icol,jrow);
      sprintf(ctitle,"Residual in tg_th for column %d and row %d \n",icol,jrow);
      hres_th.push_back(new TH1F(cname,ctitle,nbin,thlo,thhi));
      sprintf(cname,"phres%d_%d",icol,jrow);
      sprintf(ctitle,"Residual in tg_ph for column %d and row %d \n",icol,jrow);
      hres_ph.push_back(new TH1F(cname,ctitle,nbin,phlo,phhi));
      htoi.push_back(idx);
      tgth_hole[idx] = 1000+1000*idx; // initial value (= not found)
      tgph_hole[idx] = 1000+1000*idx;
    }
  }
  
  char strin[80];

  while (fgets(strin,80,fd)) {

    if(verbose) cout << "strin "<<strin<<endl;
    Int_t istrl = 0;
    if( strstr(strin,"x,y")!=NULL) istrl=1;  // istrl==0 is a line skip
    
    sscanf(strin,"x,y =  %d %d %f %f ",&row,&col,&ftgth,&ftgph);

    if(verbose) cout << "row "<<row<<"  col "<<col<<"   tgth "<<ftgth<<"   tgph "<<ftgph<<endl;
    if(istrl) {
      if (col>=0 && col<NCOL) {
	col_has_hole[col] = 1;
	if (row>=0 && row<NROW) {
	  idx = col*NROW + row;
          hole_found[idx] = 1;
	  tgth_hole[idx] = ftgth;
          tgph_hole[idx] = ftgph;
	}
      }
    }

   }

   Int_t jdeb=0;  
      
   numevts = (Int_t)T->GetEntries();
   if(numevts > MAXEVENTS) numevts = MAXEVENTS;
   cout << "number of events "<<numevts<<endl;
   
   for (Int_t ievt=0; ievt<numevts; ievt++) {

    skipit=0;
     
    if (ievt>0 && (ievt%1000)==0) cout << "event "<<ievt<<endl;

    tent = T->GetEntry(ievt);

// minimize radius in angle space.

    rrtol = 5;  // # sigma of radius
    rrmin = rrtol;    
    icolmin = -1;
    irowmin = -1;

    if(verbose) cout << "EVENT "<<ievt<<" ----------------- "<<NCOL<<"  "<<NROW<<endl;
    for (icol=0; icol<NCOL; icol++) {
      if (col_has_hole[icol]==1) {
        for (jrow=0; jrow<NROW; jrow++) {
           idx = icol*NROW + jrow;
           if ( hole_found[idx]==0 ) continue;
	   //	   if(dtgph==0&&dtgth==0) jdeb=1;
	   if(dtgph==0&&dtgth==0) skipit=1;  // I don't know where these spurious zeros come from
	                                     // but they are not in every run
	   thdiff = dtgth - tgth_hole[idx];  // dtgth, dtgph are from the TTree
	   phdiff = dtgph - tgph_hole[idx];
           rrad = TMath::Sqrt( ((thdiff*thdiff)/(THWID*THWID)) + ((phdiff*phdiff)/(PHWID*PHWID)) );
           if (jdeb) cout << "tgth vs tg_ph vs holes "<<dtgph<<"  "<<dtgph<<"  "<<tgth_hole[idx]<<"  "<<tgph_hole[idx]<<endl;
	   if (rrad < rrmin) {
             rrmin = rrad;
             thdiff_save = thdiff;
             phdiff_save = phdiff;
	     irowmin = jrow;
             icolmin = icol;
             if(verbose) cout << " *********************  min "<<rrad<<"   "<<dtgph<<"   "<<dtgth<<"   "<<tgph_hole[idx]<<"  "<<tgth_hole[idx]<<"  "<<icolmin<<"  "<<irowmin<<endl;
	   }	   
	}
      }
    }
    if (icolmin > -1 && irowmin > -1) {
      if (skipit==0) {
        hrad->Fill(rrmin);
        hthdiff->Fill(thdiff_save);
        hphdiff->Fill(phdiff_save);
        kfind=-1;
        idx = icolmin*NROW + irowmin;
        if ( hole_found[idx]==1 ) {
          for (kk=0; kk<htoi.size(); kk++) {
  	      if(idx==htoi[kk]) {
	          kfind=kk;
 	          break;
	      }
	  }
          hf1->Fill(dtgph,dtgth);
          if (kfind >= 0) {
 	       hres_th[kfind]->Fill(thdiff_save);  // residuals to holes
               hres_ph[kfind]->Fill(phdiff_save);
	  }
	}
      }
    } else {
       hf0->Fill(dtgph,dtgth);	  
    }
    
   }  // event loop
   
} // end of macro




 

